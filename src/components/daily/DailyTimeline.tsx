// src/components/daily/DailyTimeline.tsx
"use client";

import { useState, useEffect } from 'react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from '@/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle, AlertDialogTrigger } from '@/components/ui/alert-dialog';
import { ScrollArea } from "@/components/ui/scroll-area";
import type { CalendarEvent, EventFormData } from '@/lib/types';
import { EventForm } from './EventForm';
import { format, startOfDay, addHours, isSameDay, parseISO, parse } from 'date-fns';
import { CheckCircle, Clock, Zap, Calendar as CalendarIcon, PlusCircle, Edit3, Trash2 } from 'lucide-react';

// Mock function to simulate fetching events from localStorage
const fetchEventsFromStorage = async (date: Date): Promise<CalendarEvent[]> => {
  await new Promise(resolve => setTimeout(resolve, 100)); // Simulate async
  const dateKey = format(date, 'yyyy-MM-dd');
  const storedEvents = localStorage.getItem(`timeline_events_${dateKey}`);
  if (storedEvents) {
    try {
      return JSON.parse(storedEvents) as CalendarEvent[];
    } catch (e) {
      console.error("Failed to parse events from localStorage", e);
      return [];
    }
  }
  // Return sample events only if it's today and no stored events
  const today = startOfDay(new Date());
   if (isSameDay(date, today)) {
    return [
      { id: '1', title: 'Morning Standup', startTime: addHours(today, 9).toISOString(), endTime: addHours(today, 9.5).toISOString(), source: 'synced_calendar', description: 'Team daily sync' },
      { id: '2', title: 'Deep Work: Project Phoenix', startTime: addHours(today, 10).toISOString(), endTime: addHours(today, 12).toISOString(), source: 'user_planned' },
      { id: '3', title: 'Lunch Break', startTime: addHours(today, 12).toISOString(), endTime: addHours(today, 13).toISOString(), source: 'habit_log', description: 'Logged meal' },
      { id: '4', title: 'Client Meeting', startTime: addHours(today, 14).toISOString(), endTime: addHours(today, 15).toISOString(), source: 'synced_calendar' },
      { id: '5', title: 'Gym Session', startTime: addHours(today, 17.5).toISOString(), endTime: addHours(today, 18.5).toISOString(), source: 'habit_log', description: 'Completed workout habit' },
      { id: '6', title: 'AI Scheduled: Prep for tomorrow', startTime: addHours(today, 16).toISOString(), endTime: addHours(today, 16.5).toISOString(), source: 'ai_scheduled', description: 'Generated by AI scheduler'},
    ].sort((a, b) => parseISO(a.startTime).getTime() - parseISO(b.startTime).getTime());
  }
  return [];
};

// Function to save events to localStorage
const saveEventsToStorage = async (date: Date, events: CalendarEvent[]) => {
  const dateKey = format(date, 'yyyy-MM-dd');
  localStorage.setItem(`timeline_events_${dateKey}`, JSON.stringify(events));
};


const EventIcon = ({ source }: { source: CalendarEvent['source'] }) => {
  switch (source) {
    case 'synced_calendar': return <CalendarIcon className="h-4 w-4 text-blue-500" />;
    case 'user_planned': return <Clock className="h-4 w-4 text-purple-500" />;
    case 'habit_log': return <CheckCircle className="h-4 w-4 text-green-500" />;
    case 'ai_scheduled': return <Zap className="h-4 w-4 text-orange-500" />;
    default: return <CalendarIcon className="h-4 w-4 text-muted-foreground" />;
  }
};

export function DailyTimeline() {
  const [currentDate, setCurrentDate] = useState<Date | null>(null);
  const [events, setEvents] = useState<CalendarEvent[]>([]);
  const [isLoadingEvents, setIsLoadingEvents] = useState(true);
  const [currentTime, setCurrentTime] = useState<Date | null>(null);
  const [isFormOpen, setIsFormOpen] = useState(false);
  const [editingEvent, setEditingEvent] = useState<CalendarEvent | null>(null);

  useEffect(() => {
    setCurrentDate(startOfDay(new Date()));
  }, []);

  useEffect(() => {
    if (currentDate) {
      setIsLoadingEvents(true);
      fetchEventsFromStorage(currentDate).then(fetchedEvents => {
        setEvents(fetchedEvents.sort((a, b) => parseISO(a.startTime).getTime() - parseISO(b.startTime).getTime()));
        setIsLoadingEvents(false);
      });
    }
  }, [currentDate]);

  useEffect(() => {
    if (currentDate && !isLoadingEvents) {
      saveEventsToStorage(currentDate, events);
    }
  }, [events, currentDate, isLoadingEvents]);

  useEffect(() => {
    setCurrentTime(new Date()); // Set initial time
    const timerId = setInterval(() => {
      setCurrentTime(new Date());
    }, 60000);
    return () => clearInterval(timerId);
  }, []);

  const timeSlots = Array.from({ length: 24 }, (_, i) => {
    // This will use the correct currentDate once it's set, or a fallback if rendered before.
    // However, the main component has a loading state based on currentDate.
    const baseDateForSlot = currentDate || startOfDay(new Date()); 
    const hour = startOfDay(baseDateForSlot);
    hour.setHours(i);
    return hour;
  });

  const handleOpenForm = (eventToEdit?: CalendarEvent) => {
    if (!currentDate) return; // Should not happen if button is disabled
    setEditingEvent(eventToEdit || null);
    setIsFormOpen(true);
  };

  const handleCloseForm = () => {
    setIsFormOpen(false);
    setEditingEvent(null);
  };

  const handleFormSubmit = (data: EventFormData) => {
    const startTimeISO = parse(data.startTime, "yyyy-MM-dd'T'HH:mm", new Date()).toISOString();
    const endTimeISO = parse(data.endTime, "yyyy-MM-dd'T'HH:mm", new Date()).toISOString();

    if (editingEvent) {
      setEvents(prevEvents =>
        prevEvents.map(ev =>
          ev.id === editingEvent.id ? { ...ev, ...data, startTime: startTimeISO, endTime: endTimeISO } : ev
        ).sort((a, b) => parseISO(a.startTime).getTime() - parseISO(b.startTime).getTime())
      );
    } else {
      const newEvent: CalendarEvent = {
        id: `event-${Date.now()}`,
        ...data,
        startTime: startTimeISO,
        endTime: endTimeISO,
      };
      setEvents(prevEvents => [...prevEvents, newEvent].sort((a, b) => parseISO(a.startTime).getTime() - parseISO(b.startTime).getTime()));
    }
    handleCloseForm();
  };

  const handleDeleteEvent = (eventId: string) => {
    setEvents(prevEvents => prevEvents.filter(ev => ev.id !== eventId));
  };

  const renderCurrentTimeIndicator = () => {
    if (!currentTime || !currentDate || !isSameDay(currentDate, currentTime)) {
      return null;
    }
    const minutesPastMidnight = currentTime.getHours() * 60 + currentTime.getMinutes();
    const topOffsetRem = (minutesPastMidnight / 60) * 6;

    return (
      <div
        className="absolute left-16 right-0 ml-1 h-0.5 bg-red-500 z-10 flex items-center"
        style={{ top: `${topOffsetRem}rem` }}
        aria-label="Current time"
      >
        <div className="absolute -left-2 h-2 w-2 rounded-full bg-red-500 -translate-x-full"></div>
      </div>
    );
  };

  if (!currentDate) {
    return (
      <Card className="h-full flex flex-col">
        <CardHeader className="flex flex-row items-center justify-between">
          <div>
            <CardTitle className="font-headline text-xl">
              Daily Timeline - Loading date...
            </CardTitle>
            <CardDescription>View and manage your day's schedule.</CardDescription>
          </div>
          <Button disabled> {/* Disable button while loading date */}
            <PlusCircle className="mr-2 h-4 w-4" /> Add Event
          </Button>
        </CardHeader>
        <CardContent className="flex-grow overflow-hidden">
          <div className="flex items-center justify-center h-full">
            <p>Initializing timeline...</p>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="h-full flex flex-col">
      <CardHeader className="flex flex-row items-center justify-between">
        <div>
          <CardTitle className="font-headline text-xl">
            Daily Timeline - {format(currentDate, 'EEEE, MMMM do')}
          </CardTitle>
          <CardDescription>View and manage your day's schedule.</CardDescription>
        </div>
        <Dialog open={isFormOpen} onOpenChange={(open) => { if (!open) handleCloseForm(); else setIsFormOpen(true); }}>
          <DialogTrigger asChild>
            <Button onClick={() => handleOpenForm()} disabled={!currentDate}>
              <PlusCircle className="mr-2 h-4 w-4" /> Add Event
            </Button>
          </DialogTrigger>
          <DialogContent className="sm:max-w-[525px]">
            <DialogHeader>
              <DialogTitle className="font-headline">{editingEvent ? 'Edit Event' : 'Add New Event'}</DialogTitle>
            </DialogHeader>
            {currentDate && ( // Ensures EventForm only renders if currentDate is available
              <EventForm 
                onSubmit={handleFormSubmit} 
                onCancel={handleCloseForm} 
                initialData={editingEvent || undefined}
                currentDate={currentDate}
              />
            )}
          </DialogContent>
        </Dialog>
      </CardHeader>
      <CardContent className="flex-grow overflow-hidden">
        {isLoadingEvents ? (
          <div className="flex items-center justify-center h-full">
            <p>Loading timeline...</p>
          </div>
        ) : (
          <ScrollArea className="h-[calc(100vh-280px)] pr-4 relative">
            <div className="relative">
              {timeSlots.map((slot, index) => (
                <div key={index} className="flex items-start h-24 border-b border-dashed">
                  <div className="w-16 pr-2 text-right text-xs text-muted-foreground pt-1 sticky top-0 bg-card">
                    {format(slot, 'ha')}
                  </div>
                  <div className="flex-1 relative"></div>
                </div>
              ))}
              
              {renderCurrentTimeIndicator()}

              {events.map(event => {
                const start = parseISO(event.startTime);
                const end = parseISO(event.endTime);
                const startMinutesPastMidnight = start.getHours() * 60 + start.getMinutes();
                const endMinutesPastMidnight = end.getHours() * 60 + end.getMinutes();

                const topOffsetRem = (startMinutesPastMidnight / 60) * 6; 
                const heightRem = Math.max(((endMinutesPastMidnight - startMinutesPastMidnight) / 60) * 6, 2);

                return (
                  <div
                    key={event.id}
                    className="absolute left-16 right-0 ml-2 p-2 rounded-lg shadow-md group"
                    style={{ 
                      top: `${topOffsetRem}rem`, 
                      height: `${heightRem}rem`,
                      backgroundColor: 'hsl(var(--primary) / 0.1)',
                      borderLeft: '4px solid hsl(var(--primary))',
                    }}
                    aria-label={`Event: ${event.title} from ${format(start, 'p')} to ${format(end, 'p')}`}
                  >
                    <div className="flex items-start justify-between h-full">
                        <div className="flex items-start gap-2 overflow-hidden">
                            <EventIcon source={event.source} />
                            <div className="flex-grow">
                                <p className="font-semibold text-sm text-primary-foreground leading-tight truncate">{event.title}</p>
                                <p className="text-xs text-muted-foreground leading-tight">
                                {format(start, 'p')} - {format(end, 'p')}
                                </p>
                                {event.description && <p className="text-xs text-muted-foreground mt-1 leading-tight truncate">{event.description}</p>}
                            </div>
                        </div>
                        <div className="flex flex-col sm:flex-row items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity duration-200 shrink-0">
                            <Button variant="ghost" size="icon" className="h-7 w-7" onClick={() => handleOpenForm(event)}>
                                <Edit3 className="h-4 w-4" />
                                <span className="sr-only">Edit event</span>
                            </Button>
                            <AlertDialog>
                                <AlertDialogTrigger asChild>
                                    <Button variant="ghost" size="icon" className="h-7 w-7 text-destructive hover:text-destructive">
                                        <Trash2 className="h-4 w-4" />
                                        <span className="sr-only">Delete event</span>
                                    </Button>
                                </AlertDialogTrigger>
                                <AlertDialogContent>
                                <AlertDialogHeader>
                                    <AlertDialogTitle>Are you sure?</AlertDialogTitle>
                                    <AlertDialogDescription>
                                    This action cannot be undone. This will permanently delete the event
                                    "{event.title}".
                                    </AlertDialogDescription>
                                </AlertDialogHeader>
                                <AlertDialogFooter>
                                    <AlertDialogCancel>Cancel</AlertDialogCancel>
                                    <AlertDialogAction onClick={() => handleDeleteEvent(event.id)} className="bg-destructive hover:bg-destructive/90">
                                    Delete
                                    </AlertDialogAction>
                                </AlertDialogFooter>
                                </AlertDialogContent>
                            </AlertDialog>
                        </div>
                    </div>
                  </div>
                );
              })}
            </div>
          </ScrollArea>
        )}
      </CardContent>
    </Card>
  );
}
